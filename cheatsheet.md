[TOC]

# 信息的表示和处理

## 数据长度

| 类型 | Intel IA32 | x86-64 |
| :--: | :--------: | :----: |
| char |     1      |   1    |
| int  |     4      |   4    |
| long |     **4**      |   **8**    |
| long long |     **8**      |   **8**    |
| short |     2      |   2    |
| float |     4      |   4    |
| double |     8      |   8    |
| pointer |    **4**      |   **8**    |

Intel IA32 要求 `double` 和 `long long` 对齐到 4 字节边界，带 `double` 和 `long long` 的结构体也要对齐到 4 字节边界。

## 整数字面量

整数是以数字开头的。`-2147483647` 是一个常量表达式。

字面量推导的规则：
- ISO C99：
    - 十进制：`int`、`long`、`long long`（**永远都会是有符号数**）
    - 十六进制：`int`、`unsigned`、`long`、`unsigned long`、`long long`、`unsigned long long`
- ISO C90：
    - 十进制：`int`、`long`、`unsigned`、`unsigned long`
    - 十六进制：`int`、`unsigned`、`long`、`unsigned long`

`-2147483648` 中的 `2147483648` 参与类型推导。它在 ISO C90 32 位的机器上会被推导为 `unsigned`；在 ISO C90 64 位的机器上会被推导为 `long`；而在 ISO C99 的机器上被推导为 `long long`（32 位）和 `long`（64 位）。之后，`-2147483648` 作为一个常量表达式被运算。在被推导为 `unsigned` 的情况下，$-2147483648 == 2^32 - 2147483648 = 2147483648$。

`2147483647 + 1 < 2147483648` 在 ISO C90 32 位下为假，因为右边的 `2147483648` 被推导为 `unsigned` 类型。

x86-64 里，`char` 一般是有符号的。


## `double` 不一定比 `float` 精确

```c
float f1 = 0.1, f2 = 0.2, f3 = 0.3;
double d1 = 0.1, d2 = 0.2, d3 = 0.3;
f1 + f2 == f3;    // true
d1 + d2 == d3;    // false
```

1. `0.1` 和 `0.2` 和 `0.3` 在二进制下都是无限循环小数 循环节长是 4
2. `float` 和 `double` 的 `frac` 一个是 4 的倍数 一个不是
3. 因此在末尾的舍入可能导致不同的行为

## 运算符优先级

| 优先级 |                                    运算符                                    |  结合律  |
| :----: | :--------------------------------------------------------------------------: | :------: |
|   1    |                后缀运算符：`()`、`[]`、`.`、`->`、`++`、`--`                 | 从左到右 |
|   2    |  一元运算符：`++`、`--`、`!`、`~`、`+`、`-`、`*`、`&`、`sizeof`、`_Alignof`  | 从右到左 |
|   3    |                                类型转换运算符                                | 从右到左 |
|   4    |                         乘除法运算符：`*`、`/`、`%`                          | 从左到右 |
|   5    |                          **加减法运算符**：`+`、`-`                          | 从左到右 |
|   6    |                          **移位运算符**：`<<`、`>>`                          | 从左到右 |
|   7    |                     **关系运算符**：`<`、`<=`、`>`、`>=`                     | 从左到右 |
|   8    |                          **相等运算符**：`==`、`!=`                          | 从左到右 |
|   9    |                            **按位与运算符**：`&`                             | 从左到右 |
|   10   |                           **按位异或运算符**：`^`                            | 从左到右 |
|   11   |                             **按位或运算符**：`                              |    `     | 从左到右 |
|   12   |                            **逻辑与运算符**：`&&`                            | 从左到右 |
|   13   |                             **逻辑或运算符**：`                              |          | `        | 从左到右 |
|   14   |                             **条件运算符**：`?:`                             | 从右到左 |
|   15   | **赋值运算符**：`=``+=`、`-=`、`*=`、`/=`、`%=`、`<<=`、`>>=`、`&=`、`^=`、` |    =`    | 从右到左 |
|   16   |                             **逗号运算符**：`,`                              | 从左到右 |



## 负数编码

原码（Sign-Magnitude）：最高位决定符号，其余位不变（IEEE 754 浮点数）
反码（One's Complement）：最高位决定符号，若最高位为 `1` 则其余位取反

## 取模

`a % b = a - a / b * b`

`-9 % 4 == -1`，而不是 3。

## 大端小端

**x86-64 是小端法**

```c
// Small endian
char* s = "2018";    // 0x32 0x30 0x31 0x38
int* p = (int*)s;
// *p == 0x38313032!
short s1 = (*p) >> 12;    // 3 hex digits!
unsigned u = s1;
printf("0x%x\n", u);    // 0xffff8313
```

## 运算

（`x` `y` 为 `int`，`ux` `uy` 为 `unsigned`）

**异或有交换律和结合律**

`x ^ y ^ x == y`
`x ^ y ^ x ^ y ^ x == x`
`x ^ y ^ (~x) - y == y ^ x ^ (~y) - x`

`((x >> 1) << 1) <= x` 恒为真



## 未定义行为

- 非良构（ill-formed）
- 非良构而不要求诊断（ill-formed no diagnostic required）
- 实现定义行为（implementation-def）
- 未定义行为（undefined behavior, ined behavior）
- 未指明行为（unspecified behaviorUB）

编译器假设程序永远不会包含未定义行为。

**`char` 类型有无符号是未定义行为**

**有符号整数溢出是未定义行为**，无符号整数溢出不是未定义行为

**解引用空指针是未定义行为**

**访问未初始化变量是未定义行为**

C 标准不强制 IEEE 754，（也不强制补码）因此除以零是未定义的。

IEEE 754 规定除以零得无穷，`0/0` 除外，结果为 NaN。

```c
char *p = "wikipedia"; // valid C, deprecated in C++98/C++03, ill-formed as of C++11
p[0] = 'W'; // undefined behavior
```

```c
// Meaningless checks from real code:
// pointer p; signed int x;
if (p + 100 < p)    // ptr overflow
if (x + 100 < x)    // signed int overflow
if (!(1 << x))      // oversized shift
*p; if (p)          // null pointer dereference
if (abs(x) < 0)     // Absolute value overflow
```


## 其他

当 $x=\operatorname{TMin}_{32}$ 时，$-x=x$. 这同时说明 $\operatorname{Tmin}+\operatorname{Tmin}=0$

IA32 下，`long` 和 `int` 都是 4 字节的，x86-64 中，`long` 是 8 字节的，`int` 是 4 字节的。

IA32 架构中，`((-9)>>1) + sizeof(long) > 0`
- **右移运算向下舍入**，`(-9)>>1 == -5`
- `sizeof(long) == 4`
- `sizeof` 的**返回值是无符号数，参与的运算结果必定非负**

```c
int x = 42;
char c = 'a';
&x - &c;    // error! 
// &x 的类型是 int*, &c 的类型是 char*
// 它们不是 ptr to compatible type, 不允许相减

int y = 56;
&x - &y;    // 结果并不是地址差 而是 (地址差) / sizeof(int)！

void* ptr;
ptr + 2;    // 地址增加 2 字节, 即 void* 的 sizeof 是 1 
```

```c
// C 中, 字符字面量的类型是 int
printf("sizeof char: %lld\n", sizeof (char));    // 1   
char a = 'a';    
printf("sizeof a: %lld\n", sizeof a);   // 1
printf("sizeof 'a': %lld", sizeof 'a');    // 4
```



## 浮点

**NaN 是无序的。有 NaN 参与的运算结果为 `false`**。NaN 和任何数不会比较相等，包括自身。

浮点加法有交换律，但是 `a + b == b + a` 在 `a` 和 `b` 都不是 NaN 的时候仍不一定成立。**因为 `-inf + inf == inf + (-inf)` 返回 `0`**。

若 `d < 0`，则 `d * 2` 也小于 `0`。但是 `d * d` 不一定大于 `0`，因为 `d * d` 可能为 `0`。


# 程序的机器级表示

| 四字（64位） | 双字（32位） | 字（16位） | 字节（8位） |     用途     |
| :----------: | :----------: | :--------: | :---------: | :----------: |
|    `%rax`    |    `%eax`    |   `%ax`    |    `%al`    |    返回值    |
|    `%rbx`    |    `%ebx`    |   `%bx`    |    `%bl`    | 被调用者保存 |
|    `%rcx`    |    `%ecx`    |   `%cx`    |    `%cl`    | 第 4 个参数  |
|    `%rdx`    |    `%edx`    |   `%dx`    |    `%dl`    | 第 3 个参数  |
|    `%rsi`    |    `%esi`    |   `%si`    |   `%sil`    | 第 2 个参数  |
|    `%rdi`    |    `%edi`    |   `%di`    |   `%dil`    | 第 1 个参数  |
|    `%rbp`    |    `%ebp`    |   `%bp`    |   `%bpl`    | 被调用者保存 |
|    `%rsp`    |    `%esp`    |   `%sp`    |   `%spl`    |    栈指针    |
|    `%r8`     |    `%r8d`    |   `%r8w`   |   `%r8b`    | 第 5 个参数  |
|    `%r9`     |    `%r9d`    |   `%r9w`   |   `%r9b`    | 第 6 个参数  |
|    `%r10`    |   `%r10d`    |  `%r10w`   |   `%r10b`   |  调用者保存  |
|    `%r11`    |   `%r11d`    |  `%r11w`   |   `%r11b`   |  调用者保存  |
|    `%r12`    |   `%r12d`    |  `%r12w`   |   `%r12b`   | 被调用者保存 |
|    `%r13`    |   `%r13d`    |  `%r13w`   |   `%r13b`   | 被调用者保存 |
|    `%r14`    |   `%r14d`    |  `%r14w`   |   `%r14b`   | 被调用者保存 |
|    `%r15`    |   `%r15d`    |  `%r15w`   |   `%r15b`   | 被调用者保存 |

`%rbx`、`%rbp`、`%r12`、`%r13`、`%r14`、`%r15` 是被调用者保存寄存器；`%rax`、`%rdi`、`%rsi`、`%rdx`、`%rcx`、`%r8`、`%r9`、`%r10`、`%r11` 都是调用者保存寄存器；`%rsp` 两者都不是。

- `CF`：进位标志。最近的操作使最高位产生了进位。可用于检查无符号数的溢出。
- `ZF`：零标志。最近的操作结果为 0.
- `SF`：符号标志。最近的操作结果为负数。
- `OF`：溢出标志。最近的操作导致补码溢出。

`SET` 指令根据条件码的某种组合设置一个字节的值。

|   指令    |  同义名  |   条件码组合   |        设置条件         |
| :-------: | :------: | :------------: | :---------------------: |
| `sete D`  |  `setz`  |      `ZF`      |        相等 / 零        |
| `setne D` | `setnz`  |     `~ZF`      |       不等 / 非零       |
| `sets D`  |          |      `SF`      |           负            |
| `setns D` |          |     `~SF`      |          非负           |
| `setg D`  | `setnle` | `~(SF^OF)&~ZF` |    大于（有符号 >）     |
| `setge D` | `setnl`  |   `~(SF^OF)`   |  大于等于（有符号 >=）  |
| `setl D`  | `setnge` |    `SF^OF`     |    小于（有符号 <）     |
| `setle D` | `setng`  |    `(SF^OF)    |           ZF`           | 小于等于（有符号 <=） |
| `seta D`  | `setnbe` |   `~CF&~ZF`    |    超过（无符号 >）     |
| `setae D` | `setnb`  |     `~CF`      | 超过或相等（无符号 >=） |
| `setb D`  | `setnae` |      `CF`      |    低于（无符号 <）     |
| `setbe D` | `setna`  |    `CF\|ZF`    | 低于或相等（无符号 <=） |

有符号比较使用 `SF` 和 `OF` 条件码，无符号比较使用 `CF` 和 `ZF` 条件码。

**`set D` 中的目标位置 `D` 必须是单字节寄存器**。

参数按顺序依次存储在 `%rdi`、`%rsi`、`%rdx`、`%rcx`、`%r8` 和 `%r9` 中，它们都是调用者保存寄存器。


在 64 位机器上，地址总是 64 位的，因此像 `(%eax)` 这样的操作数很有可能是错误的，我们认为它不合法。不过 `(%eax, %ebx)` 是合法的。比例因子必须是 1、2、4 或 8，`(, %rax, 3)` 不合法。

`clto` 指令把 `%rax` 的值符号扩展，结果存放在 `%rdx`（高 64 位）和 `%rax`（低 64 位）两个寄存器中

右移也会改变进位标志

`sar %ebx`

**无条件跳转可以是直接跳转，也可以是间接跳转**。

**条件跳转只能是直接跳转**。

`call` 可以间接跳转


**通过栈传递参数时，所有数据大小向 8 的倍数对齐**

`for` 和对应 `while` 转写的区别：`continue` 语句被跳过

结构体的大小等于其最大成员大小的整数倍?

可变栈帧

gcc 一次申请的栈空间大小必须是 8 的倍数，且大于 16 字节。

在调用新函数过程之前，`%rsp` 要 8 字节对齐（默认）或 16 字节对齐（ABI 规定，-fPIC 编译）

局部变量被引用前需要放置到栈上，这些变量的放置需要与自身字节对齐

`leave` 指令将帧指针恢复到原始值，释放整个栈帧。执行它如同执行 `movq %rbp, %rsp; popq %rbp`。


`cqto`
`idivq Src`
`divq Src`
`imulq Src` `mulq Src` 


在 Intel 文档里，`cqto` 叫做 `cqo`。

**注意无符号数的条件码**

x86-64 的 `char` 是有符号的

**寻址中的立即数不带 `$`**：`123(%rsp, %rbx, 4)`

## 其他

两个数组: 内存别名引用!


# 处理器体系结构

逻辑门：圆 AND，尖 OR，三角 NOT